/***************************************************************************
* bezier.cpp   (container plugin)                                          *
*                                                                          *
* The Bezier object is a container object that returns a collection of     *
* triangles or quads that approximate a bicubic Bezier patch defined by    *
* a mesh of 16 control points.  The returned objects are added, one by one,*
* into whatever aggregate object the container is added to.                *
*                                                                          *
* The tessellation generated by the Bezier object is controlled by a number*
* of parameters that the reader recognizes.  All of the following          *
* keywords & arguments can follow the name "bezier".                       *
*                                                                          *
*    1)   control-points <x> <y> <z> <x> <y> <z> ... <x> <y> <z>           *
*    2)   tessellation <n> <m>                                             *
*    3)   triangules                                                       *
*    4)   quads                                                            *
*    5)   with-normals                                                     *
*    6)   without-normals                                                  *
*                                                                          *
* The first is how the control points are specified.  It expects 48 numbers*
* defining the 16 control points.  The others set state that affects how   *
* subsequent bezier patches are handled.  The default is a 4x4 tessellation*
* into quads, which are then divided into triangles without normals.  The  *
* result is a collection of 32 flat triangles.                             *
*                                                                          *
* Parameters that are set in one "bezier" object are the defaults for all  *
* subsequent bezier objects.  Thus, bezier objects can be used to simply   *
* set parameters.                                                          *
*                                                                          *
* This object requires both "triangle" and "quad" plugins.                 *
*                                                                          *
* History:                                                                 *
*   05/11/2010  Moved triangle generation into Tessellation base class.    *
*   04/15/2010  Ported tessellation code from Apollo Computer version.     *
*   10/21/2005  Initial coding.                                            *
*                                                                          *
***************************************************************************/
#include <string>
#include <iostream>
#include "toytracer.h"
#include "params.h"
#include "mat3x4.h"
#include "util.h"
#include "tessellation.h"

using std::string;

namespace __bezier_container__ {

struct Bezier : Tessellation {
    Bezier() {}
    virtual ~Bezier() {}
    virtual Plugin *ReadString( const string &params );
    virtual string MyName() const { return "bezier"; }
    virtual void Eval( double u, double v, Vec3 &P, Vec3 &N ) const;
    static Vec3 control_point[4][4];
    static unsigned tessellate_u;
    static unsigned tessellate_v;
    static bool triangulate;
    static bool with_normals;
    };

REGISTER_PLUGIN( Bezier );

Vec3 Bezier::control_point[4][4];

unsigned
    Bezier::tessellate_u = 4,
    Bezier::tessellate_v = 4;

bool
    Bezier::triangulate  = true,
    Bezier::with_normals = false;

// Read a Bezier control mesh or parameters that control tessellation from
// a string.
Plugin *Bezier::ReadString( const string &params )
    {
    static Interval unit( 0.0, 1.0 );
    Bezier *result = NULL;
    ParamReader get( params );
    if( !get[MyName()] ) return NULL;

    // Process the rest of the line to handle parameter-setting options and
    // reading control points.

    while( !get.isEmpty() )
        {
        // Process all the simple flags...
        if( get["with-normals"]    ) { with_normals = true;  continue; } 
        if( get["without-normals"] ) { with_normals = false; continue; }
        if( get["triangles"]       ) { triangulate  = true;  continue; }
        if( get["quads"]           ) { triangulate  = false; continue; }

        // Look for keywords that are followed by arguments.

        if( get["tessellation"] )
            {
            unsigned nu, nv;
            if( get[nu] && get[nv] )
                {
                tessellate_u = nu;
                tessellate_v = nv;
                }
            else return NULL;
            continue;
            }

        if( get["control-points"] )
            {
            get.EnableIndexing( false );
            // Grab the 16 control points of the cubic Bezier patch.
            // Transform the control points by the current matrix associated
            // with Bezier objects.  This way we needn't transform the
            // resulting triangles or quads.
            for( int i = 0; i < 4; i++ )
            for( int j = 0; j < 4; j++ )
                {
                double x, y, z;
                if( !( get[x] && get[y] && get[z] ) ) return NULL;
                control_point[i][j] = Vec3( x, y, z );
                }
            // If this is the first set of control points, create a new
            // Bezier container object for them.  If a container already
            //  exists, then add the new tessellation to it.
            if( result == NULL ) result = new Bezier();
            result->EnableSymmetry( no_symmetry );
            result->EnableNormals ( with_normals );
            result->Tessellate( unit, tessellate_u, unit, tessellate_v );
            continue;
            }

        if( get["indexed-control-points"] )
            {
            get.EnableIndexing( true );
            // Grab the 16 control points of the cubic Bezier patch.
            Vec3 mesh[16];
            for( int i = 0; i < 4; i++ )
            for( int j = 0; j < 4; j++ )
                {
                Vec3 v;
                if( !( get[v] ) ) return NULL;
                control_point[i][j] = v;
                }
            // If this is the first set of control points, create a new
            // Bezier container object for them.  If a container already
            //  exists, then add the new tessellation to it.
            if( result == NULL ) result = new Bezier();
            result->EnableSymmetry( no_symmetry );
            result->EnableNormals ( with_normals );
            result->Tessellate( unit, tessellate_u, unit, tessellate_v );
            continue;
            }
 
        get.Warning( "unprocessed parameters to " + MyName() );
        break;
        }

    // Return either a pointer to an actual Bezier container object that holds
    // one or more tessellations, or a "Null" plugin, indicating that all we did
    // was set parameters.
    return ( result == NULL ) ? Plugin::Null : result;
    }

// First four Bernstein polynomials.
inline double B( unsigned i, double x )
    {
    switch( i )
        {
        case 0: return ( 1.0 + x * ( -3.0 + x * (  3.0 - x       )));
        case 1: return (       x * (  3.0 + x * ( -6.0 + x * 3.0 )));
        case 2: return (       x * (        x * (  3.0 - x * 3.0 )));
        case 3: return (       x * (        x * (        x       )));
        }
    return 0;
    }

// Derivatives of first four Bernstein polynomials (divided by 3).
inline double dB( unsigned i, double x )
    {
    switch( i )
        {
        case 0: return ( -1.0 + x * (   2.0 - x       ));
        case 1: return (  1.0 + x * (  -4.0 + x * 3.0 ));
        case 2: return (        x * (   2.0 - x * 3.0 ));
        case 3: return (        x * (         x       ));
        }
    return 0;
    }

// Evaluate the Bezier patch at the parameters (u,v) to produce the point
// P(u,v).  Also compute the normal N(u,v) at that point.
void Bezier::Eval( double u, double v, Vec3 &P, Vec3 &N ) const
    {
    Vec3 U, V;
    P.Zero();
    for( unsigned i = 0; i < 4; i++ )
        {
        const double Bu(  B( i, u ) );
        const double Du( dB( i, u ) );
        for( unsigned j = 0; j < 4; j++ )
            {
            const Vec3 C( control_point[i][j] );
            const double Bv(  B( j, v ) );
            const double Dv( dB( j, v ) );
            P += ( Bu * Bv ) * C;
            U += ( Bv * Du ) * C;
            V += ( Bu * Dv ) * C;
            }
        }
    N = Unit( U ^ V );
    }

} // namespace __bezier_container__





